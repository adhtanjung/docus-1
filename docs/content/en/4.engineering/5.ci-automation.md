---
title: CI & Automation
description: Required checks, merge gates, and automation strategy.
---

# CI / Automation Workflow

Continuous Integration (CI) is the automated backbone of code quality. It provides objective, repeatable verification that code meets baseline standards before it can be merged.

## Required Checks (Merge Gates)

A PR cannot be merged if any of the following checks fail.

| Check                    | Purpose                                        | Tool                    |
| :----------------------- | :--------------------------------------------- | :---------------------- |
| **Build**                | Ensures the project compiles without errors.   | `pnpm build`            |
| **Unit Tests**           | Validates individual units of code.            | `pnpm test:unit`        |
| **Integration Tests**    | Validates interactions between modules.        | `pnpm test:integration` |
| **Linting**              | Enforces code style and catches common errors. | `eslint`                |
| **Formatting**           | Ensures consistent code formatting.            | `prettier`              |
| **Type Checking**        | Catches type errors at compile time.           | `tsc --noEmit`          |
| **Security Scan (SAST)** | Identifies potential vulnerabilities.          | (e.g., Snyk, Semgrep)   |

## The Golden Rule

::prose-note
**A PR cannot be merged if CI fails â€” no exceptions.** If a check is flaky or broken, fix the check rather than bypassing it.
::

## Pipeline Stages

A typical CI pipeline runs in the following order:

::steps

### 1. Install Dependencies

Install all project dependencies (`pnpm install`).

### 2. Lint & Format

Run linters and formatters to catch style issues early.

### 3. Type Check

Run the TypeScript compiler to catch type errors.

### 4. Unit Tests

Execute fast-running unit tests.

### 5. Build

Compile the project to ensure it can be built.

### 6. Integration Tests

Run tests that require database or external service interaction.

### 7. Security Scan

Analyze code for known vulnerabilities.
::

## AI-Specific CI Considerations

For PRs flagged as AI-assisted, the following additional measures are recommended:

| Measure                         | Description                                       |
| :------------------------------ | :------------------------------------------------ |
| **Stricter Coverage Threshold** | Require higher test coverage for new code.        |
| **Large Diff Warning**          | Automatically flag PRs exceeding size limits.     |
| **Enhanced Static Analysis**    | Run additional rules to catch common AI patterns. |

## Handling Flaky Tests

Flaky tests (tests that sometimes pass and sometimes fail) undermine trust in CI.

- **Quarantine**: Move flaky tests to a separate suite while investigating.
- **Root Cause Analysis**: Identify the source of non-determinism.
- **Fix or Remove**: A flaky test is worse than no test.

## Branch-Specific Rules

| Branch      | CI Level                                    |
| :---------- | :------------------------------------------ |
| `main`      | Full pipeline (all checks, security scan)   |
| `develop`   | Full pipeline                               |
| `feature/*` | Core checks (lint, type, unit tests, build) |
| `hotfix/*`  | Full pipeline (expedited)                   |

## Local Pre-Commit Hooks

To catch issues before they reach CI, developers should use local hooks.

### Recommended Hooks (via Husky/lint-staged)

- **Pre-commit**: Run linter and formatter on staged files.
- **Pre-push**: Run type checking.

## Notifications

- **Failure Alerts**: Notify the author immediately on CI failure.
- **Main Branch Alerts**: Notify the team if `main` or `develop` builds break.
